buildscript {
    repositories {
        jcenter()
    }

    dependencies {
        classpath 'com.bmuschko:gradle-docker-plugin:3.0.7'
    }
}

apply plugin: com.bmuschko.gradle.docker.DockerRemoteApiPlugin


import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.Dockerfile
import com.bmuschko.gradle.docker.tasks.image.DockerPushImage


configurations {
    dockerConf
}

//Docker only dependencies, these will not be added to the final jar
dependencies {
    dockerConf group: "com.bmuschko", name: "gradle-docker-plugin", version: "3.0.7"
}

ext {

    if (project.hasProperty('dockerTag')){
        tagversion = dockerTag
    } else {
        tagversion = project.version
    }

}


task copyDependencies(type: org.gradle.api.tasks.Copy) {
    doFirst {
        println("Copying dependencies for ${project.name}, version ${project.version}")
    }

    dependsOn fatJar
    from 'docker/'
    from "build/libs/${project.name}-${project.version}-all.jar"
    into "build/docker/"
    rename ("${project.name}-${project.version}-all.jar", "subs.jar")
}

task createDockerfile(type: Dockerfile) {
    dependsOn copyDependencies

    destFile = project.file('build/docker/Dockerfile')

    from 'openjdk:8-jre-stretch'
    maintainer '05_Technology_6_Recs.OnCall@uk.tesco.com "05_Technology_6_Recs.OnCall@uk.tesco.com"'

    environmentVariable 'API_HOME','/opt/app/'
    runCommand 'mkdir -p $API_HOME'

    copyFile "*", '$API_HOME'

    environmentVariable 'TMP_OPTS','-Djava.io.tmpdir=/tmp'

    //Vertx settings
    environmentVariable 'VERTX_OPTS','-Dvertx.metrics.options.enabled=true -Dvertx.logger-delegate-factory-class-name=io.vertx.core.logging.SLF4JLogDelegateFactory'

    // JVM options settings for SLF4J
    environmentVariable 'LOGBACK_OPTS','-Dhazelcast.logging.type=slf4j -Dlogback.configurationFile=file:///opt/app/logback.xml'

    // Compile all of them adding the heap coming from the kubernetes yaml file when the dockerfile is called
    environmentVariable 'API_OPTS','$ENV_OPTS $TMP_OPTS $VERTX_OPTS $LOGBACK_OPTS'

    workingDir '$API_HOME'

    exposePort 9014

    runCommand 'apt-get update'
    runCommand 'apt-get install wget'
    runCommand 'mkdir -p /opt/init'
    runCommand 'wget -O /opt/init/dumb-init https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64'
    runCommand 'chmod +x /opt/init/dumb-init'

    entryPoint '/opt/init/dumb-init', '--'
    defaultCommand 'bash', '-c', '/opt/app/entrypoint.sh'
}

task buildImage(type: DockerBuildImage) {
    dependsOn createDockerfile

    inputDir = createDockerfile.destFile.parentFile
    tag = project.dockerRepository + ":${tagversion}"
}

docker {
    registryCredentials {
        url = "${project.dockerRepository}"
        username = 'AWS'
        password = project.hasProperty("awsDockerPassword") ? awsDockerPassword : ''
        //Password is set at runtime through generateDockerPassword
    }
}

// Assumes the existence of env/dev/aws-access.sh keys file (not under version control)
task generateDockerPassword(type: Exec) {

    workingDir 'docker-scripts'
    commandLine './get-docker-login.sh'

    standardOutput new ByteArrayOutputStream()
    errorOutput    new ByteArrayOutputStream()

    doLast {
        ext.awsDockerPassword = standardOutput.toString()
        docker.registryCredentials.password = ext.awsDockerPassword
        println ext.awsDockerPassword
        println errorOutput.toString()
    }
}

task pushImage(type: DockerPushImage) {
    dependsOn  buildImage,generateDockerPassword
    imageName = buildImage.tag
}

